---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: logstash
  namespace: elastic
spec:
  replicas: 1
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        name: logstash
    spec:
      containers:
      - name: logstash
        image: logstash:7.2.0
        env:
        - name: LS_JAVA_OPTS
          value: -Xmx256m -Xms256m
        args: [
          "--config.reload.automatic"
        ]
        volumeMounts:
        - mountPath: /usr/share/logstash/pipeline
          name: config
      restartPolicy: Always
      volumes:
      - name: config
        configMap:
          name: logstash-config
          items:
          - key: logstash.conf
            path: logstash.conf
---
apiVersion: v1
kind: Service
metadata:
  name: logstash
  namespace: elastic
  labels:
    name: logstash
spec:
  ports:
    - name: beats
      port: 5000
      targetPort: 5000
    - name: http
      port: 8080
      targetPort: 8080
  selector:
    name: logstash
---
apiVersion: v1
kind: Service
metadata:
  name: logstash-tcp
  namespace: elastic
  labels:
    name: logstash
spec:
  type: NodePort
  ports:
    - name: tcp
      port: 8088
      nodePort: 30088
    - name: syslog
      port: 8888
      nodePort: 30888
  selector:
    name: logstash
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: logstash-mon2
  namespace: elastic
  annotations:
    kubernetes.io/ingress.class: traefik
    traefik.frontend.rule.type: PathPrefixStrip
spec:
  rules:
  - host: mon2.rudenspavasaris.id.lv
    http:
      paths:
      - path: /
        backend:
          serviceName: logstash
          servicePort: http
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: logstash-config
  namespace: elastic
data:
  logstash.conf: |-
    input {
      beats {
        port => 5000
      }
      http {
        codec => line
        host => "0.0.0.0"
        port => "8080"
        tags => ["input-http"]
      }
      tcp {
        codec => line
        host => "0.0.0.0"
        port => "8088"
        tags => ["input-http"]
      }
      syslog {
        codec => line
        host => "0.0.0.0"
        port => "8888"
        tags => ["input-http"]
      }
    }

    output {
      if "input-http" in [tags] {
        elasticsearch {
            hosts => "elasticsearch:9200"
            index => "http-%{+YYYY.MM.dd}"
        }
      } else {
          elasticsearch {
            hosts => "elasticsearch:9200"
            index => "%{[@metadata][beat]}-%{+YYYY.MM.dd}"
          }
      }
    }

    filter {
      # if [event][module] == "haproxy" {
      if "input-http" in [tags] {
         grok {
            match => {
               "message" => [
                  "%{HAPROXY_DATE:[haproxy][request_date]} %{IPORHOST:[haproxy][source]} %{PROG:[process][name]}(?:\[%{POSINT:[process][pid]:long}\])?: %{GREEDYDATA} %{IPORHOST:[source][address]}:%{POSINT:[source][port]:long} %{WORD} %{IPORHOST:[destination][ip]}:%{POSINT:[destination][port]:long} \(%{WORD:[haproxy][frontend_name]}/%{WORD:[haproxy][mode]}\)",
                  "(%{NOTSPACE:[process][name]}\[%{NUMBER:[process][pid]:long}\]: )?%{IP:[source][address]}:%{NUMBER:[source][port]:long} \[%{NOTSPACE:[haproxy][request_date]}\] %{NOTSPACE:[haproxy][frontend_name]} %{NOTSPACE:[haproxy][backend_name]}/%{NOTSPACE:[haproxy][server_name]} %{NUMBER:[haproxy][http][request][time_wait_ms]:long}/%{NUMBER:[haproxy][total_waiting_time_ms]:long}/%{NUMBER:[haproxy][connection_wait_time_ms]:long}/%{NUMBER:[haproxy][http][request][time_wait_without_data_ms]:long}/%{NUMBER:[temp][duration]:long} %{NUMBER:[http][response][status_code]:long} %{NUMBER:[haproxy][bytes_read]:long} %{NOTSPACE:[haproxy][http][request][captured_cookie]} %{NOTSPACE:[haproxy][http][response][captured_cookie]} %{NOTSPACE:[haproxy][termination_state]} %{NUMBER:[haproxy][connections][active]:long}/%{NUMBER:[haproxy][connections][frontend]:long}/%{NUMBER:[haproxy][connections][backend]:long}/%{NUMBER:[haproxy][connections][server]:long}/%{NUMBER:[haproxy][connections][retries]:long} %{NUMBER:[haproxy][server_queue]:long}/%{NUMBER:[haproxy][backend_queue]:long} (\{%{DATA:[haproxy][http][request][captured_headers]}\} \{%{DATA:[haproxy][http][response][captured_headers]}\} |\{%{DATA}\} )?\"%{GREEDYDATA:[haproxy][http][request][raw_request_line]}\"",
                  "(%{NOTSPACE:[process][name]}\[%{NUMBER:[process][pid]:long}\]: )?%{IP:[source][address]}:%{NUMBER:[source][port]:long} \[%{NOTSPACE:[haproxy][request_date]}\] %{NOTSPACE:[haproxy][frontend_name]}/%{NOTSPACE:[haproxy][bind_name]} %{GREEDYDATA:[haproxy][error_message]}",
                  "%{HAPROXY_DATE} %{IPORHOST:[haproxy][source]} (%{NOTSPACE:[process][name]}\[%{NUMBER:[process][pid]:long}\]: )?%{IP:[source][address]}:%{NUMBER:[source][port]:long} \[%{NOTSPACE:[haproxy][request_date]}\] %{NOTSPACE:[haproxy][frontend_name]} %{NOTSPACE:[haproxy][backend_name]}/%{NOTSPACE:[haproxy][server_name]} %{NUMBER:[haproxy][total_waiting_time_ms]:long}/%{NUMBER:[haproxy][connection_wait_time_ms]:long}/%{NUMBER:[temp][duration]:long} %{NUMBER:[haproxy][bytes_read]:long} %{NOTSPACE:[haproxy][termination_state]} %{NUMBER:[haproxy][connections][active]:long}/%{NUMBER:[haproxy][connections][frontend]:long}/%{NUMBER:[haproxy][connections][backend]:long}/%{NUMBER:[haproxy][connections][server]:long}/%{NUMBER:[haproxy][connections][retries]:long} %{NUMBER:[haproxy][server_queue]:long}/%{NUMBER:[haproxy][backend_queue]:long}"
               ]
            }
            pattern_definitions => {
              "HAPROXY_DATE" => "(%{MONTHDAY}[/-]%{MONTH}[/-]%{YEAR}:%{HOUR}:%{MINUTE}:%{SECOND})|%{SYSLOGTIMESTAMP}"
            }
         }
         date {
            match => [
               "[haproxy][request_date]",
               "dd/MMM/yyyy:HH:mm:ss][SSS]",
               "MMM dd HH:mm:ss"
            ]
            target => "@timestamp"
         }
         grok {
            match => {
               "source.address" => "^%{IP:[source][ip]}$"
            }
         }
         geoip {
            source => "[source][ip]"
            target => "[source][geo]"
         }
         mutate {
          convert => {
            "[destination][port]" => "integer"
            "[haproxy][connections][active]" => "integer"
            "[haproxy][connections][backend]" => "integer"
            "[haproxy][connections][frontend]" => "integer"
            "[haproxy][connections][retries]" => "integer"
            "[haproxy][connections][server]" => "integer"
            "[process][pid]" => "integer"
            "[source][port]" => "integer"
            "[temp][duration]" => "integer"
            "[haproxy][backend_queue]" => "integer"
            "[haproxy][bytes_read]" => "integer"
            "[haproxy][connection_wait_time_ms]" => "integer"
            "[haproxy][server_queue]" => "integer"
            "[haproxy][total_waiting_time_ms]" => "integer"
          }
        }
      }
    }
